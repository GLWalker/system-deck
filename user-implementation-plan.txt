Data Discovery & Database Architecture Planning

(SystemDeck / Admin Drawer / SystemPress Ecosystem)

1. Guiding Principles (Lock These In First)

Before touching schema diagrams:
	1.	Data must be categorized by intent, not feature
	‚Ä¢	Features evolve; intent does not.
	‚Ä¢	Example: ‚ÄúPinned overlay guides‚Äù and ‚ÄúPinned inspector widgets‚Äù are both user-state spatial data.
	2.	Separation of concerns is non-negotiable
	‚Ä¢	WP Core data ‚â† SystemDeck user data ‚â† Shell/session state ‚â† Public overlays.
	‚Ä¢	If it can be user-scoped, it must be user-scoped.
	3.	Real-time first, persistence second
	‚Ä¢	Assume live propagation is required.
	‚Ä¢	Database is the source of truth, not the transport layer.
	4.	Everything is addressable
	‚Ä¢	Page ID, Template ID, Theme, Viewport, User, Workspace, Context.
	‚Ä¢	No anonymous blobs.

‚∏ª

2. Phase 1 ‚Äî Deep Data Discovery Crawl

Objective

Identify every location where data is saved, mutated, or fetched across:
	‚Ä¢	system-deck
	‚Ä¢	admin-drawer
	‚Ä¢	admin-drawer-archive
	‚Ä¢	WordPress core touchpoints (user meta, post meta, options, REST, autosave hooks)

Crawl Methodology (No Code Yet)

For each plugin/module:

A. Identify Save Points
Look for:
	‚Ä¢	update_option
	‚Ä¢	update_user_meta
	‚Ä¢	update_post_meta
	‚Ä¢	REST endpoints that accept POST / PUT
	‚Ä¢	JS state persisted via AJAX or REST
	‚Ä¢	Local/session storage used as temporary state

Log:
	‚Ä¢	What data
	‚Ä¢	Who owns it
	‚Ä¢	What context it belongs to
	‚Ä¢	How often it changes

B. Identify Fetch Points
Look for:
	‚Ä¢	Initial bootstraps
	‚Ä¢	Viewport changes
	‚Ä¢	Page/template switches
	‚Ä¢	Theme.json reads
	‚Ä¢	Inspector widget hydration

Log:
	‚Ä¢	Blocking vs non-blocking
	‚Ä¢	Scope (global vs contextual)
	‚Ä¢	Latency sensitivity

C. Identify Ephemeral State
These should never go straight to DB:
	‚Ä¢	Drag position during interaction
	‚Ä¢	Hover state
	‚Ä¢	Temporary inspector values
	‚Ä¢	Live resize metrics

These inform schema shape, but not persistence rules.

‚∏ª

3. Phase 2 ‚Äî Data Categorization Matrix

Everything discovered must land in one and only one bucket.

Core Categories

1. WordPress User Data (WP-Native)
Owner: WordPress
Scope: User
Examples:
	‚Ä¢	Capabilities
	‚Ä¢	Preferences that affect WP UI globally
	‚Ä¢	Admin color schemes

Rule:
üëâ Only stored via WP APIs
üëâ Never SystemDeck-specific logic here

‚∏ª

2. SystemDeck User Data
Owner: SystemDeck
Scope: User
Examples:
	‚Ä¢	Preferred tools
	‚Ä¢	Inspector widget layouts
	‚Ä¢	Personal pinboards
	‚Ä¢	Ribbon grid configurations

Traits:
	‚Ä¢	User-specific
	‚Ä¢	Portable across sites (future)
	‚Ä¢	Frequently accessed

‚∏ª

3. SystemDeck Shell / State Data
Owner: SystemDeck Runtime
Scope: User √ó Context
Examples:
	‚Ä¢	Open panels
	‚Ä¢	Dock positions
	‚Ä¢	Active workspace
	‚Ä¢	Responsive viewer state

Traits:
	‚Ä¢	Fast read/write
	‚Ä¢	Session-aware
	‚Ä¢	Often overwritten

‚∏ª

4. SystemPress Workspace Data
Owner: SystemPress
Scope: Site √ó Context
Examples:
	‚Ä¢	Page-level pins
	‚Ä¢	Template-level overlays
	‚Ä¢	Theme.json telemetrics snapshots
	‚Ä¢	Grid overlays intended for collaboration or reference

Traits:
	‚Ä¢	Context-bound
	‚Ä¢	May be shared across users
	‚Ä¢	Versioned over time

‚∏ª

5. Public Overlay / Presentation Data
Owner: Site
Scope: Page / Template / Theme
Examples:
	‚Ä¢	Front-end overlays
	‚Ä¢	Visual annotations
	‚Ä¢	Public grid systems

Traits:
	‚Ä¢	Read-heavy
	‚Ä¢	Immutable during render
	‚Ä¢	Must be cache-friendly

‚∏ª

4. Phase 3 ‚Äî Context Resolution Model

Every stored record must resolve to a Context Signature.

Required Context Axes

Not all are always present, but schema must allow them:
	‚Ä¢	user_id (nullable)
	‚Ä¢	site_id
	‚Ä¢	post_id (page, post)
	‚Ä¢	template_id
	‚Ä¢	theme_slug
	‚Ä¢	viewport (xs / sm / md / lg / xl / custom)
	‚Ä¢	workspace_id
	‚Ä¢	tool_id
	‚Ä¢	state_type

This is the backbone that enables:
	‚Ä¢	Page-specific saving
	‚Ä¢	Template inheritance
	‚Ä¢	Responsive overrides
	‚Ä¢	Multi-workspace support

‚∏ª

5. Phase 4 ‚Äî Database Schema Strategy (Conceptual)

Schema Philosophy
	‚Ä¢	Few tables, strongly typed
	‚Ä¢	Keys over JSON blobs
	‚Ä¢	JSON only for flexible payloads
	‚Ä¢	Indexes are first-class citizens

Logical Table Families (Not SQL Yet)

A. Entity Tables
Define what something is:
	‚Ä¢	Workspaces
	‚Ä¢	Tools
	‚Ä¢	Pin Items
	‚Ä¢	Inspector Widgets

B. State Tables
Define how it currently exists:
	‚Ä¢	Positions
	‚Ä¢	Visibility
	‚Ä¢	Active flags
	‚Ä¢	Layer order

C. Context Tables
Define where it applies:
	‚Ä¢	Page bindings
	‚Ä¢	Template bindings
	‚Ä¢	Viewport overrides

D. Telemetrics Tables
Define measured data:
	‚Ä¢	Theme.json metrics
	‚Ä¢	Grid calculations
	‚Ä¢	Responsive breakpoints
	‚Ä¢	Computed layout data

‚∏ª

6. Phase 5 ‚Äî Real-Time Propagation Plan

Data Flow Model
	1.	User Interaction
	‚Ä¢	Local state updates immediately
	2.	State Commit
	‚Ä¢	Debounced persistence
	‚Ä¢	Batched writes
	3.	Propagation
	‚Ä¢	REST/WebSocket layer
	‚Ä¢	Context-aware broadcasting
	4.	Hydration
	‚Ä¢	Scoped fetch by context signature
	‚Ä¢	Minimal payloads

Rule:

Never refetch what you already know
Never broadcast what doesn‚Äôt apply

‚∏ª

7. Phase 6 ‚Äî Schema Governance

This prevents future pain.

Mandatory Practices
	‚Ä¢	Schema versioning
	‚Ä¢	Migration ledger
	‚Ä¢	Change log per table
	‚Ä¢	Explicit ownership per table

Every Change Requires:
	‚Ä¢	Reason
	‚Ä¢	Data category
	‚Ä¢	Context scope
	‚Ä¢	Read/write frequency
	‚Ä¢	Index justification

‚∏ª

8. Deliverables (What You Should Produce Next)
	1.	Data Discovery Map
	‚Ä¢	One document listing all save/fetch points
	2.	Categorization Table
	‚Ä¢	Every data type ‚Üí category ‚Üí scope
	3.	Context Signature Definition
	‚Ä¢	Canonical reference used everywhere
	4.	Database Blueprint Diagram
	‚Ä¢	Logical, not SQL
	5.	Propagation Strategy Doc
	‚Ä¢	How data moves in real time